# Prompt Optimizer Module - Implementation Plan

## 1. Overview

### 1.1 Purpose
The Prompt Optimizer module will bridge the gap between human language and AI language by taking user-written prompts and transforming them into high-quality, optimized prompts that AI models expect. This will improve the quality of outputs generated by AI models and enhance user experience.

### 1.2 Goals
- Transform natural human language prompts into structured, optimized AI prompts
- Improve prompt clarity, specificity, and effectiveness
- Support multiple AI models (GPT-4, Claude, DALL-E, Midjourney, etc.)
- Provide optimization suggestions and explanations
- Track optimization history and improvements
- Integrate seamlessly with existing prompt module

### 1.3 Key Features
- **Interactive Question-Based Optimization**: Ask smart, context-aware questions to understand user intent
- **Intent Preservation**: Never add creative details (colors, styles, backgrounds) that user didn't specify
- **Flexible Input System**: Support predefined options + custom "Other" inputs + free-form additional details
- **Two-Tier Optimization**: Quick (grammar only) and Premium (with questions) modes
- **Model-Specific Optimization**: Tailor prompts for specific AI models
- **Quality Scoring**: Rate prompt quality before and after optimization
- **Version History**: Track original and optimized versions
- **Learning from Feedback**: Improve optimization based on user feedback

---

## 2. Architecture & Design

### 2.1 Module Structure
```
src/
├── controllers/
│   └── promptOptimizer.controller.ts    # Request handlers
├── services/
│   ├── promptOptimizer.service.ts        # Business logic
│   └── aiOptimization.service.ts         # AI/LLM integration
├── models/
│   └── promptOptimization.model.ts       # Database schema
├── routes/
│   └── promptOptimizer.routes.ts         # API routes
├── validation/
│   └── promptOptimizer.schema.ts         # Zod validation schemas
├── types/
│   └── promptOptimizer.types.ts          # TypeScript types
└── utils/
    └── promptAnalyzer.util.ts             # Prompt analysis utilities
```

### 2.2 Data Flow

#### Quick Optimization Flow
```
User Input (Human Language Prompt)
    ↓
[Validation Layer]
    ↓
[Prompt Analyzer] → Identify missing elements
    ↓
[Rule-Based Optimization] → Grammar + Structure fixes only
    ↓
[Quick Optimized Prompt]
    ↓
[Response to User]
```

#### Premium Optimization Flow
```
User Input (Human Language Prompt)
    ↓
[Validation Layer]
    ↓
[Prompt Analyzer] → Analyze what's missing
    ↓
[Question Generator] → Generate 3-5 smart questions
    ↓
[User Answers Questions] → Predefined options + Custom inputs + Additional details
    ↓
[Answer Parser] → Extract structured data from free-form inputs
    ↓
[Prompt Builder] → Combine original + answers into premium prompt
    ↓
[AI Enhancement] → Final polish with AI (optional)
    ↓
[Premium Optimized Prompt]
    ↓
[Database Storage]
    ↓
[Response to User]
```

### 2.3 Integration Points
- **Existing Prompt Module**: Optimized prompts can be saved as regular prompts
- **User Module**: Track optimization history per user
- **Admin Module**: Analytics and monitoring of optimization usage

---

## 3. Database Schema

### 3.1 PromptOptimization Model
```typescript
{
  _id: ObjectId,
  user: ObjectId (ref: User),              // User who requested optimization
  originalPrompt: String,                  // Original user input
  optimizedPrompt: String,                 // Optimized version
  targetModel: String,                     // AI model (GPT-4, Claude, DALL-E, etc.)
  mediaType: String,                       // 'text', 'image', 'video', 'audio'
  optimizationType: String,                // 'quick', 'premium'
  optimizationMode: String,               // 'analyze', 'build', 'complete'
  
  // Question-based optimization data
  questions: [{
    id: String,                            // Question identifier
    question: String,                       // Question text
    type: String,                           // 'select', 'select_or_text', 'textarea'
    priority: String,                       // 'high', 'medium', 'low'
    answered: Boolean,                      // Whether user answered
    answer: {                               // User's answer
      type: String,                         // 'option', 'custom', 'default', 'skipped'
      value: String,                        // Answer value
      customText: String                    // If type is 'custom'
    }
  }],
  additionalDetails: String,               // Free-form additional details from user
  userAnswers: Object,                     // Complete answers object for reference
  
  // Quality metrics
  qualityScore: {
    before: Number,                        // 0-100
    after: Number,                         // 0-100
    improvements: [String],                // List of improvements made
    intentPreserved: Boolean                // Whether original intent was maintained
  },
  metadata: {
    wordCount: { before: Number, after: Number },
    clarityScore: { before: Number, after: Number },
    specificityScore: { before: Number, after: Number },
    structureScore: { before: Number, after: Number },
    completenessScore: Number              // How complete the prompt is (0-100)
  },
  analysis: {
    missingElements: [String],             // What was missing from original
    grammarFixed: Boolean,                 // Whether grammar was corrected
    structureImproved: Boolean             // Whether structure was improved
  },
  suggestions: [{
    type: String,                          // 'add', 'remove', 'modify', 'reorder'
    section: String,                       // Which part of prompt
    original: String,                      // Original text
    suggested: String,                     // Suggested text
    reason: String                         // Why this change improves the prompt
  }],
  promptContext: {
    useCase: String,                        // 'creative', 'technical', 'business', etc.
    outputType: String,                     // 'text', 'image', 'code', etc.
    tone: String,                           // 'professional', 'casual', 'formal', etc.
    length: String                          // 'short', 'medium', 'long'
  },
  status: String,                          // 'pending', 'analyzing', 'questions_ready', 'building', 'completed', 'failed'
  error: String,                           // Error message if failed
  createdAt: Date,
  updatedAt: Date
}
```

### 3.2 Indexes
- `{ user: 1, createdAt: -1 }` - User's optimization history
- `{ targetModel: 1, createdAt: -1 }` - Model-specific queries
- `{ status: 1 }` - Status filtering

### 3.3 Relationship with Prompt Model
- **Option 1**: Add `optimizationId` field to Prompt model (reference)
- **Option 2**: Add `originalPromptId` to PromptOptimization model
- **Option 3**: Keep them separate, link via user and timestamps

**Recommended**: Option 2 - Add `originalPromptId` to track if optimization was based on existing prompt

---

## 4. API Endpoints

### 4.1 Core Endpoints

#### POST `/api/v1/prompt-optimizer/quick-optimize`
**Purpose**: Quick optimization (grammar + structure only, no questions)

**Request Body**:
```json
{
  "originalPrompt": "create image of cat",
  "targetModel": "DALL-E 3",
  "mediaType": "image"
}
```

**Response**:
```json
{
  "status": "success",
  "data": {
    "originalPrompt": "create image of cat",
    "optimizedPrompt": "Create an image of a cat",
    "improvements": [
      "Fixed grammar (added 'a')",
      "Improved verb for AI models ('create' instead of 'draw')"
    ],
    "qualityScore": {
      "before": 43,
      "after": 65,
      "intentPreserved": true
    },
    "note": "Quick optimization preserves your original intent. Use premium optimization for more detailed prompts."
  }
}
```

#### POST `/api/v1/prompt-optimizer/analyze`
**Purpose**: Analyze prompt and generate smart questions (Step 1 of premium optimization)

**Request Body**:
```json
{
  "originalPrompt": "create image of cat",
  "targetModel": "DALL-E 3",
  "mediaType": "image"
}
```

**Response**:
```json
{
  "status": "success",
  "data": {
    "originalPrompt": "create image of cat",
    "analysis": {
      "completenessScore": 30,
      "missingElements": ["style", "composition", "background", "quality_indicators"],
      "grammarFixed": true,
      "structureImproved": false
    },
    "questions": [
      {
        "id": "style",
        "question": "What style do you prefer?",
        "type": "select_or_text",
        "priority": "high",
        "options": [
          { "value": "photorealistic", "label": "Photorealistic" },
          { "value": "cartoon", "label": "Cartoon/Illustration" },
          { "value": "artistic", "label": "Artistic/Painting" },
          { "value": "abstract", "label": "Abstract" },
          { "value": "minimalist", "label": "Minimalist" },
          { "value": "no_preference", "label": "No preference" },
          { "value": "custom", "label": "Other (describe your style)", "allowsTextInput": true }
        ],
        "default": "photorealistic",
        "required": false
      },
      {
        "id": "composition",
        "question": "How should the cat be positioned?",
        "type": "select_or_text",
        "priority": "medium",
        "options": [
          { "value": "centered", "label": "Centered" },
          { "value": "rule_of_thirds", "label": "Rule of thirds" },
          { "value": "close_up", "label": "Close-up" },
          { "value": "full_body", "label": "Full body" },
          { "value": "portrait", "label": "Portrait style" },
          { "value": "no_preference", "label": "No preference" },
          { "value": "custom", "label": "Other (describe)", "allowsTextInput": true }
        ],
        "default": "centered",
        "required": false
      },
      {
        "id": "background",
        "question": "What background do you want?",
        "type": "select_or_text",
        "priority": "medium",
        "options": [
          { "value": "indoor", "label": "Indoor" },
          { "value": "outdoor", "label": "Outdoor" },
          { "value": "studio", "label": "Studio/Plain" },
          { "value": "transparent", "label": "Transparent" },
          { "value": "natural", "label": "Natural environment" },
          { "value": "no_preference", "label": "No preference" },
          { "value": "custom", "label": "Other (describe)", "allowsTextInput": true }
        ],
        "default": "natural",
        "required": false
      },
      {
        "id": "quality",
        "question": "What quality level?",
        "type": "select",
        "priority": "low",
        "options": [
          { "value": "standard", "label": "Standard" },
          { "value": "high", "label": "High quality" },
          { "value": "professional", "label": "Professional/8K" },
          { "value": "no_preference", "label": "No preference" }
        ],
        "default": "high",
        "required": false
      }
    ],
    "additionalDetails": {
      "id": "additional_details",
      "question": "Any additional details you'd like to include?",
      "type": "textarea",
      "placeholder": "E.g., 'orange tabby with green eyes', 'sitting on a windowsill', 'golden hour lighting', 'cozy atmosphere' - Add anything else you want!",
      "required": false,
      "note": "This is optional - add any specific details, colors, moods, references, or characteristics you have in mind"
    },
    "quickOptimized": "Create an image of a cat",
    "note": "Answer these questions to get a premium optimized prompt, or use the quick version above. All questions are optional - you can skip any or use defaults."
  }
}
```

#### POST `/api/v1/prompt-optimizer/build`
**Purpose**: Build premium prompt from answers (Step 2 of premium optimization)

**Request Body**:
```json
{
  "originalPrompt": "create image of cat",
  "targetModel": "DALL-E 3",
  "mediaType": "image",
  "answers": {
    "style": {
      "type": "custom",
      "value": "watercolor with soft pastel colors"
    },
    "composition": {
      "type": "option",
      "value": "close_up"
    },
    "background": {
      "type": "custom",
      "value": "vintage library with bookshelves"
    },
    "quality": {
      "type": "option",
      "value": "high"
    },
    "additional_details": "orange tabby cat, golden hour lighting streaming through window, cozy reading atmosphere, tiny reading glasses on the cat"
  }
}
```

**Response**:
```json
{
  "status": "success",
  "data": {
    "originalPrompt": "create image of cat",
    "optimizedPrompt": "Create a high-quality, watercolor-style image with soft pastel colors, featuring a close-up of an orange tabby cat, set in a vintage library with bookshelves, golden hour lighting streaming through window, cozy reading atmosphere, tiny reading glasses on the cat, professional art style",
    "breakdown": {
      "base": "Create a high-quality image of an orange tabby cat",
      "style": "watercolor-style with soft pastel colors, professional art style",
      "composition": "close-up",
      "background": "vintage library with bookshelves",
      "lighting": "golden hour lighting streaming through window",
      "mood": "cozy reading atmosphere",
      "details": "tiny reading glasses on the cat"
    },
    "qualityScore": {
      "before": 43,
      "after": 97,
      "improvements": [
        "Fixed grammar",
        "Added custom style (watercolor with soft pastels)",
        "Added custom composition (close-up)",
        "Added custom background (vintage library)",
        "Added lighting details (golden hour)",
        "Added mood (cozy reading atmosphere)",
        "Added specific details (orange tabby, glasses)",
        "Structured for DALL-E 3"
      ],
      "intentPreserved": true
    },
    "metadata": {
      "completenessScore": 98,
      "clarityScore": 95,
      "specificityScore": 97,
      "structureScore": 95
    }
  }
}
```

#### POST `/api/v1/prompt-optimizer/optimize` (Legacy - for backward compatibility)
**Purpose**: Single-call optimization (combines analyze + build with defaults)

#### POST `/api/v1/prompt-optimizer/batch-optimize`
**Purpose**: Optimize multiple prompts at once

**Request Body**:
```json
{
  "prompts": [
    {
      "originalPrompt": "...",
      "targetModel": "...",
      "optimizationType": "..."
    },
    ...
  ]
}
```

#### GET `/api/v1/prompt-optimizer/history`
**Purpose**: Get user's optimization history

**Query Parameters**:
- `page`: number (default: 1)
- `limit`: number (default: 20)
- `targetModel`: string (filter by model)
- `sort`: 'newest' | 'oldest' | 'improvement' (default: 'newest')

#### GET `/api/v1/prompt-optimizer/:id`
**Purpose**: Get specific optimization details

#### POST `/api/v1/prompt-optimizer/:id/apply`
**Purpose**: Apply optimized prompt to create/save as a new Prompt

**Request Body**:
```json
{
  "title": "Optimized Prompt Title",
  "description": "...",
  "tags": ["..."],
  "isPublic": true
}
```

#### POST `/api/v1/prompt-optimizer/:id/feedback`
**Purpose**: Submit feedback on optimization quality

**Request Body**:
```json
{
  "rating": 5,                              // 1-5
  "wasHelpful": true,
  "comments": "Optional feedback text"
}
```

#### DELETE `/api/v1/prompt-optimizer/:id`
**Purpose**: Delete optimization record

### 4.2 Admin Endpoints (Optional)

#### GET `/api/v1/admin/prompt-optimizer/stats`
**Purpose**: Get optimization statistics

#### GET `/api/v1/admin/prompt-optimizer/analytics`
**Purpose**: Get detailed analytics

---

## 5. Service Layer Design

### 5.1 PromptOptimizer Service
**Responsibilities**:
- Validate input
- Orchestrate optimization process
- Store results in database
- Handle errors and retries
- Manage optimization history
- Generate smart questions based on prompt analysis
- Parse user answers and build optimized prompts

**Key Functions**:
- `quickOptimize(input)`: Fast grammar + structure optimization
- `analyzePrompt(input)`: Analyze prompt and generate questions
- `buildOptimizedPrompt(input, answers)`: Build premium prompt from answers
- `generateQuestions(prompt, mediaType, targetModel)`: Generate context-aware questions
- `parseAnswers(answers, questions)`: Parse and structure user answers
- `extractDetailsFromFreeText(freeText)`: Extract structured data from free-form input
- `batchOptimize(prompts)`: Batch processing
- `getOptimizationHistory(userId, filters)`: History retrieval
- `getOptimizationById(id)`: Single optimization retrieval
- `applyOptimization(optimizationId, promptData)`: Create prompt from optimization
- `submitFeedback(optimizationId, feedback)`: Store user feedback
- `deleteOptimization(id, userId)`: Delete optimization

### 5.2 AI Optimization Service
**Responsibilities**:
- Interface with external AI APIs
- Generate optimization prompts
- Analyze prompt quality
- Extract suggestions and improvements

**Key Functions**:
- `callOptimizationAPI(prompt, config)`: Call external AI service
- `analyzePromptQuality(prompt)`: Quality scoring
- `generateOptimization(prompt, targetModel, context)`: Main optimization logic
- `extractSuggestions(original, optimized)`: Generate improvement suggestions
- `calculateQualityScores(original, optimized)`: Score calculation

**AI Service**: Google Gemini Pro
- **Model**: `gemini-1.5-flash` (free tier: 1,500 requests/day, 15 requests/minute)
- **Why Gemini**: Excellent instruction following, great at understanding context, perfect for prompt optimization tasks
- **API**: Google Generative AI SDK (`@google/generative-ai`)
- **Fallback Option**: Groq (if rate limits are hit - 14,400 requests/day)

**Key Functions Using Gemini**:
- `generateQuestionsWithGemini(prompt, mediaType)`: Generate context-aware questions
- `parseAnswersWithGemini(freeText)`: Extract structured data from free-form input
- `buildPromptWithGemini(original, answers)`: Build final optimized prompt

### 5.3 Prompt Analyzer Utility
**Responsibilities**:
- Analyze prompt structure
- Extract prompt components
- Identify missing elements based on prompt science
- Calculate metrics
- Determine what questions to ask

**Key Functions**:
- `analyzeStructure(prompt)`: Parse prompt structure
- `extractKeywords(prompt)`: Extract key terms
- `identifyMissingElements(prompt, mediaType)`: Find what's missing (style, composition, etc.)
- `identifyIssues(prompt)`: Find potential problems
- `calculateMetrics(prompt)`: Word count, clarity, completeness, etc.
- `checkGrammar(prompt)`: Identify grammar issues
- `determineQuestionPriority(missingElements)`: Prioritize which questions to ask

---

## 6. User Experience Flow

### 6.1 Quick Optimization Flow
```
User enters: "create image of cat"
    ↓
User clicks "Quick Optimize"
    ↓
System: Grammar fix + structure improvement
    ↓
Result: "Create an image of a cat"
    ↓
Time: < 1 second
```

### 6.2 Premium Optimization Flow
```
User enters: "create image of cat"
    ↓
User clicks "Premium Optimize"
    ↓
System analyzes prompt → Identifies missing elements
    ↓
System generates 3-5 smart questions
    ↓
User sees questions with options:
  - Style: [Dropdown] or [Other: _____]
  - Composition: [Dropdown] or [Other: _____]
  - Background: [Dropdown] or [Other: _____]
  - Quality: [Dropdown]
  - Additional Details: [Large textarea]
    ↓
User answers (some questions, skips others, uses defaults)
    ↓
System parses answers + free-form input
    ↓
System builds premium optimized prompt
    ↓
Result: High-quality, detailed prompt with user's specifications
    ↓
Time: 2-5 seconds
```

### 6.3 Example: Complete Premium Flow

**Step 1: User Input**
```
"create image of cat"
```

**Step 2: Analysis & Questions**
System identifies missing: style, composition, background, quality

**Step 3: User Answers**
- Style: "watercolor with soft pastels" (custom)
- Composition: "close_up" (predefined)
- Background: [Skipped] → Default: "natural"
- Quality: "high" (predefined)
- Additional Details: "orange tabby, golden hour, cozy library, wizard hat"

**Step 4: Final Prompt**
```
"Create a high-quality, watercolor-style image with soft pastel colors, 
featuring a close-up of an orange tabby cat, set in a cozy library, 
golden hour lighting, wizard hat, professional art style"
```

## 7. Intent Preservation & Question Generation Strategy

### 6.1 Core Principle: Intent Preservation

**CRITICAL RULE**: Never add creative details (colors, backgrounds, styles, moods) that the user didn't explicitly specify. We must respect user intent and maintain their original simplicity level if that's what they want.

**What We SHOULD Do:**
- ✅ Fix grammar and spelling errors
- ✅ Improve clarity and structure
- ✅ Use AI-model-friendly language
- ✅ Add technical formatting (if needed for model)
- ✅ Remove redundancy
- ✅ Ask questions to understand user intent (don't assume)

**What We SHOULD NOT Do:**
- ❌ Add colors the user didn't specify
- ❌ Add backgrounds the user didn't mention
- ❌ Add styles the user didn't request
- ❌ Add moods or emotions the user didn't express
- ❌ Add specific details (breed, pose, setting) the user didn't provide
- ❌ Assume creative preferences

### 6.2 Question Generation Strategy

#### Context-Aware Questions
Questions should be generated based on:
1. **Media Type**: Different questions for image vs text vs video prompts
2. **Missing Elements**: Only ask about what's actually missing from the prompt
3. **Priority**: High-priority questions first (style, main subject)
4. **Optimal Count**: 3-5 questions maximum (not too few, not too many)

#### Question Types by Media Type

**For Image Prompts:**
- Style (photorealistic, cartoon, artistic, etc.) - HIGH PRIORITY
- Composition (centered, rule of thirds, close-up, etc.) - MEDIUM PRIORITY
- Background/Setting (indoor, outdoor, studio, etc.) - MEDIUM PRIORITY
- Quality Level (standard, high, professional) - LOW PRIORITY
- Lighting (natural, soft, dramatic, etc.) - LOW PRIORITY

**For Text Prompts:**
- Tone (professional, casual, formal, etc.) - HIGH PRIORITY
- Format (paragraph, list, structured, etc.) - MEDIUM PRIORITY
- Length (short, medium, long) - MEDIUM PRIORITY
- Style (conversational, technical, creative, etc.) - LOW PRIORITY

**For Video/Audio Prompts:**
- Duration - HIGH PRIORITY
- Style/Pacing - MEDIUM PRIORITY
- Technical Specs - LOW PRIORITY

### 6.3 Flexible Input System

#### Question Structure
Each question supports:
1. **Predefined Options**: Quick selection for common choices
2. **"Other" Option**: Custom text input for anything not listed
3. **"No Preference" Option**: Use sensible default
4. **Skippable**: All questions are optional

#### Additional Details Field
- Large textarea for free-form input
- User can add anything: colors, moods, specific details, references, etc.
- System intelligently parses and incorporates into final prompt

### 6.4 AI Integration for Question Generation

**System Prompt for Question Generation:**
```
Analyze this prompt: "{userPrompt}"
Media type: {mediaType}
Target model: {targetModel}

Based on prompt engineering best practices, identify what's missing that would significantly improve this prompt.

Generate 3-5 essential questions that would help create a premium prompt. Each question should:
1. Address a critical missing element
2. Have clear, simple options
3. Include a sensible default
4. Be optional (user can skip)
5. Include an "Other" option with text input capability

Return questions in priority order (high to low).

Format as JSON:
{
  "questions": [
    {
      "id": "style",
      "question": "What style do you prefer?",
      "type": "select_or_text",
      "priority": "high",
      "options": [...],
      "default": "..."
    }
  ],
  "additionalDetailsField": {
    "question": "Any additional details?",
    "type": "textarea",
    "placeholder": "..."
  }
}
```

### 6.5 AI Integration for Answer Parsing

**System Prompt for Parsing Free-Form Input:**
```
Parse this user input: "{userFreeText}"

Extract structured information:
- Style/artistic direction
- Colors/color palette
- Lighting conditions
- Mood/atmosphere
- Specific details
- Setting/background
- Composition elements
- Any other relevant characteristics

Return structured JSON with these categories. If something doesn't fit a category, include it in "other".
```

### 6.6 Final Prompt Building

**System Prompt for Building Final Prompt:**
```
Build an optimized prompt from:
Original: "{originalPrompt}"
User Answers: {userAnswers}
Additional Details: "{additionalDetails}"
Target Model: {targetModel}

CRITICAL RULES:
1. ONLY use information the user provided (original prompt + answers + additional details)
2. DO NOT add creative details not mentioned by the user
3. Maintain the user's original intent and simplicity level
4. Structure the prompt for {targetModel} best practices
5. Combine all user inputs intelligently

Return the optimized prompt and explain what was incorporated from user inputs.
```

### 6.7 Model-Specific Question Sets

#### DALL-E / Midjourney (Image Generation)
Questions focus on:
- Visual style (photorealistic, artistic, etc.)
- Composition and framing
- Background and setting
- Quality and technical parameters

#### GPT-4 / Claude (Text Generation)
Questions focus on:
- Tone and voice
- Format and structure
- Length and detail level
- Context and examples

#### Code Generation Models
Questions focus on:
- Programming language and framework
- Code style and conventions
- Constraints and requirements
- Output format

### 6.8 Optimization Types

1. **Quick Optimization**: Grammar + structure fixes only, no questions, instant
2. **Premium Optimization**: Interactive questions → build premium prompt

### 6.9 Error Handling & Fallbacks
- Retry logic for API failures
- Fallback to rule-based optimization if AI fails
- If question generation fails, provide basic questions from template
- Fallback to Groq if Gemini rate limit is hit
- Cache common optimizations
- Rate limiting and cost management

### 6.10 Gemini API Implementation Example

**Installation:**
```bash
npm install @google/generative-ai
```

**Service Implementation:**
```typescript
import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!);
const model = genAI.getGenerativeModel({ 
  model: 'gemini-1.5-flash',
  generationConfig: {
    temperature: 0.7,
    maxOutputTokens: 2000,
  }
});

// Generate questions for prompt
async function generateQuestions(prompt: string, mediaType: string) {
  const systemPrompt = `Analyze this prompt: "${prompt}"
Media type: ${mediaType}

Based on prompt engineering best practices, identify what's missing and generate 3-5 essential questions.
Return as JSON with questions array.`;

  const result = await model.generateContent(systemPrompt);
  return JSON.parse(result.response.text());
}

// Parse free-form user input
async function parseFreeFormInput(freeText: string) {
  const prompt = `Parse this user input: "${freeText}"
Extract structured information (style, colors, lighting, mood, details, setting, composition).
Return as JSON.`;

  const result = await model.generateContent(prompt);
  return JSON.parse(result.response.text());
}

// Build final optimized prompt
async function buildOptimizedPrompt(
  original: string, 
  answers: object, 
  additionalDetails: string,
  targetModel: string
) {
  const prompt = `Build an optimized prompt from:
Original: "${original}"
User Answers: ${JSON.stringify(answers)}
Additional Details: "${additionalDetails}"
Target Model: ${targetModel}

CRITICAL: Only use information the user provided. Do NOT add creative details not mentioned.
Return the optimized prompt.`;

  const result = await model.generateContent(prompt);
  return result.response.text();
}
```

**Error Handling with Fallback:**
```typescript
async function generateQuestionsWithFallback(prompt: string, mediaType: string) {
  try {
    return await generateQuestions(prompt, mediaType);
  } catch (error) {
    if (error.message.includes('rate limit') || error.message.includes('429')) {
      // Fallback to Groq if Gemini rate limit hit
      return await generateQuestionsWithGroq(prompt, mediaType);
    }
    // Fallback to template-based questions
    return getTemplateQuestions(mediaType);
  }
}
```

---

## 8. Validation Schemas

### 7.1 Quick Optimize Schema
```typescript
{
  originalPrompt: string (min: 5, max: 5000),
  targetModel: enum ['GPT-4', 'Claude', 'DALL-E 3', 'Midjourney', 'Stable Diffusion', 'other'],
  mediaType: enum ['text', 'image', 'video', 'audio']
}
```

### 7.2 Analyze Prompt Schema
```typescript
{
  originalPrompt: string (min: 5, max: 5000),
  targetModel: enum ['GPT-4', 'Claude', 'DALL-E 3', 'Midjourney', 'Stable Diffusion', 'other'],
  mediaType: enum ['text', 'image', 'video', 'audio']
}
```

### 7.3 Build Prompt Schema
```typescript
{
  originalPrompt: string (min: 5, max: 5000),
  targetModel: enum ['GPT-4', 'Claude', 'DALL-E 3', 'Midjourney', 'Stable Diffusion', 'other'],
  mediaType: enum ['text', 'image', 'video', 'audio'],
  answers: {
    [questionId: string]: {
      type: enum ['option', 'custom', 'default', 'skipped'],
      value: string,
      customText?: string  // If type is 'custom'
    }
  },
  additionalDetails?: string (max: 2000)  // Optional free-form input
}
```

### 7.2 Feedback Schema
```typescript
{
  rating: number (min: 1, max: 5),
  wasHelpful: boolean,
  comments: string (max: 500, optional)
}
```

---

## 9. Implementation Phases

### Phase 1: Foundation (Week 1-2)
- [ ] Create database model (PromptOptimization) with question/answer support
- [ ] Set up basic service structure
- [ ] Create validation schemas (quick, analyze, build)
- [ ] Implement quick optimization (grammar + structure only)
- [ ] Implement prompt analyzer utility
- [ ] Set up AI service integration (Google Gemini)
- [ ] Basic question generation (template-based)

### Phase 2: Core Features (Week 3-4)
- [ ] Implement AI-powered question generation
- [ ] Implement answer parsing (structured + free-form)
- [ ] Implement premium prompt building from answers
- [ ] Implement quality scoring
- [ ] Add intent preservation checks
- [ ] Implement optimization history
- [ ] Error handling and retries

### Phase 3: Integration & Enhancement (Week 5-6)
- [ ] Integrate with existing prompt module
- [ ] Add "Apply Optimization" feature
- [ ] Implement feedback system
- [ ] Add model-specific question sets
- [ ] Enhance free-form input parsing with AI
- [ ] Performance optimization
- [ ] Caching strategy for questions and optimizations

### Phase 4: Advanced Features (Week 7-8)
- [ ] Analytics and reporting
- [ ] Admin dashboard endpoints
- [ ] Learning from feedback
- [ ] A/B testing framework
- [ ] Cost optimization
- [ ] Documentation

### Phase 5: Testing & Polish (Week 9-10)
- [ ] Unit tests
- [ ] Integration tests
- [ ] Load testing
- [ ] Security audit
- [ ] Documentation updates
- [ ] Performance tuning

---

## 10. Environment Configuration

### 10.0 Getting Started with Gemini

**Step 1: Get API Key**
1. Go to https://makersuite.google.com/app/apikey
2. Sign in with your Google account
3. Click "Create API Key"
4. Copy the API key

**Step 2: Add to Environment**
- Add `GOOGLE_AI_API_KEY` to your `.env` file
- No credit card required for free tier

**Step 3: Install SDK**
```bash
npm install @google/generative-ai
```

**Free Tier Limits:**
- 1,500 requests per day
- 15 requests per minute
- Perfect for initial development and testing

### 10.1 New Environment Variables
```env
# AI Service Configuration (Google Gemini - Free Tier)
GOOGLE_AI_API_KEY=your_google_ai_api_key_here
GEMINI_MODEL=gemini-1.5-flash
OPTIMIZATION_TEMPERATURE=0.7
OPTIMIZATION_MAX_TOKENS=2000

# Fallback AI Service (Optional - Groq for higher throughput)
GROQ_API_KEY=your_groq_api_key_here (optional)
GROQ_MODEL=llama-3.1-70b-versatile (optional)

# Optimization Settings
ENABLE_PROMPT_OPTIMIZATION=true
OPTIMIZATION_CACHE_ENABLED=true
OPTIMIZATION_CACHE_TTL=3600
MAX_BATCH_OPTIMIZATION_SIZE=10
OPTIMIZATION_RATE_LIMIT=100  # per hour per user

# Rate Limiting (Gemini Free Tier Limits)
GEMINI_RATE_LIMIT_PER_MINUTE=15  # Gemini free tier: 15 req/min
GEMINI_RATE_LIMIT_PER_DAY=1500   # Gemini free tier: 1,500 req/day

# Cost Management (Free tier, but track usage)
OPTIMIZATION_FREE_TIER_LIMIT=50  # optimizations per month (can increase)
```

---

## 11. Cost Management Strategy

### 10.1 Cost Considerations
- AI API calls can be expensive
- Need to track usage per user
- Implement rate limiting
- Consider caching common optimizations

### 10.2 Strategies
1. **Caching**: Cache similar prompts to avoid redundant API calls
2. **Rate Limiting**: Limit optimizations per user per time period
3. **Tiered Access**: Free tier with limits, premium for unlimited
4. **Batch Optimization**: More efficient for multiple prompts
5. **Model Selection**: Use cheaper models for quick optimizations

### 10.3 Usage Tracking
- Track API calls per user
- Monitor costs
- Set up alerts for budget overruns
- Generate usage reports

---

## 12. Security Considerations

### 11.1 Input Validation
- Sanitize all user inputs
- Validate prompt length and content
- Prevent prompt injection attacks
- Rate limiting to prevent abuse

### 11.2 Data Privacy
- Don't log sensitive user prompts
- Encrypt stored optimizations if needed
- Comply with data retention policies
- Allow users to delete their data

### 11.3 API Security
- Secure API keys storage
- Rotate keys regularly
- Monitor for unusual activity
- Implement request signing if needed

---

## 13. Testing Strategy

### 12.1 Unit Tests
- Service layer functions
- Utility functions
- Validation schemas
- Quality scoring algorithms

### 12.2 Integration Tests
- API endpoints
- Database operations
- AI service integration
- Error handling

### 12.3 E2E Tests
- Complete optimization flow
- Batch optimization
- History retrieval
- Feedback submission

### 12.4 Performance Tests
- Response time under load
- Batch processing efficiency
- Database query performance
- API rate limiting

---

## 14. Monitoring & Analytics

### 13.1 Metrics to Track
- Number of optimizations per day
- Average quality improvement
- Most used target models
- User satisfaction (feedback ratings)
- API costs
- Error rates
- Response times

### 13.2 Logging
- Log all optimization requests
- Track errors and failures
- Monitor API usage
- Record performance metrics

### 13.3 Alerts
- High error rates
- Cost threshold exceeded
- API rate limit approaching
- Unusual usage patterns

---

## 15. Future Enhancements

### 14.1 Advanced Features
- **Multi-language Support**: Optimize prompts in different languages
- **Custom Templates**: User-defined optimization templates
- **Collaborative Optimization**: Multiple users can improve prompts
- **Version Comparison**: Compare multiple optimization versions
- **Export Options**: Export optimized prompts in various formats

### 14.2 AI Improvements
- **Fine-tuned Models**: Train custom models on prompt optimization
- **Learning System**: Improve based on user feedback
- **Context Awareness**: Learn from user's previous prompts
- **Domain-Specific Optimization**: Specialized optimization for industries

### 14.3 Integration Enhancements
- **Browser Extension**: Optimize prompts directly in browser
- **API for Third Parties**: Allow external services to use optimizer
- **Webhook Support**: Notify external services of optimizations
- **Slack/Discord Bots**: Optimize prompts in chat

---

## 16. Success Metrics

### 15.1 Key Performance Indicators (KPIs)
- **Adoption Rate**: % of users using optimizer
- **Quality Improvement**: Average quality score increase
- **User Satisfaction**: Average feedback rating
- **Retention**: Users returning to use optimizer
- **Cost Efficiency**: Cost per optimization
- **Response Time**: Average optimization time

### 16.2 Goals
- 80%+ quality score improvement on average
- < 5 second average response time (Gemini typically 1-3 seconds)
- 4+ star average user rating
- 30%+ user adoption rate
- Cost per optimization: $0.00 (using Gemini free tier)

---

## 17. Dependencies

### 17.1 New NPM Packages
```json
{
  "@google/generative-ai": "^0.2.1",  // Google Gemini API client (primary)
  "node-cache": "^5.x.x",             // Caching
  "ioredis": "^5.x.x"                 // Redis for caching (optional)
}
```

### 17.2 External Services
- **Google Gemini API** (primary) - Free tier: 1,500 requests/day
  - Get API key: https://makersuite.google.com/app/apikey
  - Documentation: https://ai.google.dev/docs
- **Groq API** (optional fallback) - Free tier: 14,400 requests/day
  - Get API key: https://console.groq.com
  - Use if Gemini rate limits are hit
- **Redis** (optional, for caching)

---

## 18. Documentation Requirements

### 17.1 API Documentation
- Swagger/OpenAPI documentation
- Request/response examples
- Error codes and messages
- Rate limiting information

### 17.2 Developer Documentation
- Architecture overview
- Service layer documentation
- AI integration guide
- Testing guide

### 17.3 User Documentation
- How to use the optimizer
- Best practices
- FAQ
- Troubleshooting guide

---

## 19. Risk Mitigation

### 18.1 Technical Risks
- **AI API Failures**: Implement retries and fallbacks
- **High Costs**: Set limits and monitoring
- **Slow Response Times**: Implement caching and async processing
- **Quality Issues**: Continuous testing and feedback loop

### 18.2 Business Risks
- **Low Adoption**: Marketing and onboarding improvements
- **Cost Overruns**: Strict budget controls
- **Competition**: Focus on unique features
- **User Expectations**: Clear communication about capabilities

---

## 20. Conclusion

This plan provides a comprehensive roadmap for implementing the Prompt Optimizer module. The phased approach allows for iterative development and testing, while the modular architecture ensures maintainability and scalability.

**Next Steps**:
1. Review and approve this plan
2. Set up development environment
3. Begin Phase 1 implementation
4. Set up monitoring and analytics
5. Plan user testing and feedback collection

---

## 21. Key Design Decisions

### 20.1 Intent Preservation
- ✅ **Decision**: Never add creative details user didn't specify
- ✅ **Implementation**: All AI prompts emphasize intent preservation
- ✅ **Validation**: Check that optimized prompt doesn't add unsolicited details

### 20.2 Question-Based Approach
- ✅ **Decision**: Use interactive questions instead of assuming user intent
- ✅ **Implementation**: Generate 3-5 context-aware questions per prompt
- ✅ **Flexibility**: Support predefined options + custom inputs + free-form details

### 20.3 Two-Tier System
- ✅ **Decision**: Quick (instant, grammar only) + Premium (questions, detailed)
- ✅ **Implementation**: Separate endpoints for quick vs premium
- ✅ **User Choice**: Let users choose based on their needs

### 20.4 Optimal Question Count
- ✅ **Decision**: 3-5 questions maximum (not too few, not too many)
- ✅ **Priority**: High-priority questions first
- ✅ **Optional**: All questions can be skipped or use defaults

## 22. Questions to Resolve

Before implementation, clarify:
1. **Budget**: What's the monthly budget for AI API calls?
2. **Pricing Model**: Will optimization be free or paid?
3. **Priority Models**: Which AI models should be prioritized?
4. **Integration Depth**: How tightly should this integrate with existing prompt module?
5. **Data Retention**: How long should optimization history be kept?
6. **User Limits**: What should be the free tier limits?
7. **Question Templates**: Should we use AI-generated questions or predefined templates per media type?

